
navigator.geolocation.getCurrentPosition()
navigator.geolocation.watchPosition()
navigator.geolocation.clearWatch()


navigator.geolocation.getCurrentPosition(function(pos) {
var latitude = pos.coords.latitude;
var longitude = pos.coords.longitude;
alert("Your position: " + latitude + ", " + longitude);
});


// Return a newly created <img> element that will (once geolocation succeeds)
// be set to display a Google map of the current location. Note that the caller
// must insert the returned element into the document in order to make it
// visible. Throws an error if geolocation is not supported in the browser
function getmap() {
// Check for geolocation support
if (!navigator.geolocation) throw "Geolocation not supported";
// Create a new <img> element, start a geolocation request to make the img
// display a map of where we are, and then return the image.
var image = document.createElement("img");
navigator.geolocation.getCurrentPosition(setMapURL);
return image;
// This function will be invoked after we return the image object, when
// (and if) the geolocation request succeeds.
function setMapURL(pos) {
// Get our position information from the argument object
var latitude = pos.coords.latitude; // Degrees N of equator
var longitude = pos.coords.longitude; // Degrees E of Greenwich
var accuracy = pos.coords.accuracy; // Meters
// Construct a URL for a static Google map image of this location
var url = "http://maps.google.com/maps/api/staticmap" +
"?center=" + latitude + "," + longitude +
"&size=640x640&sensor=true";
// Set the map zoom level using a rough heuristic
var zoomlevel=20; // Start zoomed in almost all the way
if (accuracy > 80) // Zoom out for less accurate positions
zoomlevel -= Math.round(Math.log(accuracy/50)/Math.LN2);
url += "&zoom=" + zoomlevel; // Add zoom level to the URL
// Now display the map in the image object. Thanks, Google!
image.src = url;
}
}

// Determine my location asynchronously and display it in the specified element.
function whereami(elt) {
// Pass this object as the 3rd argument to getCurrentPosition()
var options = {
// Set to true to get a higher accuracy reading (from GPS, for example)
// if available. Note, however that this can affect battery life.
enableHighAccuracy: false, // Approximate is okay: this is the default
// Set this property if a cached location is good enough.
// The default is 0, which forces location to be checked anew.
maximumAge: 300000, // A fix from the last 5 minutes is okay
// How long are you willing to wait to get the location?
// The default is Infinity and getCurrentPosition() never times out
timeout: 15000 // Don't take more than 15 seconds
};
if (navigator.geolocation) // Request position, if supported
navigator.geolocation.getCurrentPosition(success, error, options);
else
elt.innerHTMl = "Geolocation not supported in this browser";
// This function will be invoked if geolocation fails
function error(e) {
// The error object has a numeric code and a text message. Code values:
// 1: the user did not give permission to share his or her location
// 2: the browser was unable to determine the position
// 3: a timeout occurred
elt.innerHTML = "Geolocation error " + e.code + ": " + e.message;
}
// This function will be invoked if geolocation succeeds
function success(pos) {
// These are the fields that we always get. Note that the timestamp
// is in the outer object, not the inner, coords object.
var msg = "At " +
new Date(pos.timestamp).toLocaleString() + " you were within " +
pos.coords.accuracy + " meters of latitude " +
pos.coords.latitude + " longitude " +
pos.coords.longitude + ".";
// If our device returns altitude, add that information.
if (pos.coords.altitude) {
msg += " You are " + pos.coords.altitude + " Â± " +
pos.coords.altitudeAccuracy + "meters above sea level.";
}
// if our device returns speed and heading, add that, too.
if (pos.coords.speed) {
msg += " You are travelling at " +
pos.coords.speed + "m/s on heading " +
pos.coords.heading + ".";
}
elt.innerHTML = msg; // Display all the position information
}
}



<!DOCTYPE html>
<html><head><title>I'm thinking of a number...</title>
<script>
window.onload = newgame; // Start a new game when we load
window.onpopstate = popState; // Handle history events
var state, ui; // Globals initialized in newgame()
function newgame(playagain) { // Begin a new game of guess-the-number
// Set up an object to hold document elements we care about
ui = {
heading: null, // The <h1> at the top of the document.
prompt: null, // Ask the user to enter a guess.
input: null, // Where the user enters the guess.
low: null, // Three table cells for the visual representation
mid: null, // ...of the range of numbers to guess.
high: null
};
// Look up each of these element ids
for(var id in ui) ui[id] = document.getElementById(id);
// Define an event handler for the input field
ui.input.onchange = handleGuess;
// Pick a random number and initialize game state
state = {
n: Math.floor(99 * Math.random()) + 1, // An integer: 0 < n < 100
low: 0, // The lower bound (exclusive) on guesses
high: 100, // The upper bound (exclusive) on guesses
guessnum: 0, // How many guesses have been made
guess: undefined // What the last guess was
};
// Modify document content to display this initial state
display(state);
// This function is called as the onload event handler, and is also called
// by the Play Again button displayed at the end of a game. The playagain
// argument will be true in that second case. If it is true, then we save
// the new game state. But if we were called in response to a load event,
// we don't save the state. This is because load events will also occur
// when we step backwards through the browser history from some other
// document into the existing state of a game. If we were to save a new
// initial state, in that case we would overwrite the acutal historical
// state of the game. In browsers that support pushState(), the load event
// is always followed by a popstate event. So rather than saving state here,
// we wait for the popstate. If it gives us a state object, we just use
// that. Otherwise, if the popstate has a null state, we know this is
// really a new game and we use replaceState to save the new game state.
if (playagain === true) save(state);
}
// Save game state into browser history with pushState(), if it is supported
function save(state) {
if (!history.pushState) return; // Do nothing if pushState() not defined
// We'll associate a URL with the saved state. This URL displays the
// guess number, but does not encode the game state, so it is not useful
// to bookmark. We can't easily put game state in the URL because it would
// make the secret number visible in the location bar
var url = "#guess" + state.guessnum;
// Now save the state object and the URL
history.pushState(state, // State object to save
"", // State title: current browsers ignore this
url); // State URL: not useful to bookmark
}
// This is the onpopstate event handler that restores historical states.
function popState(event) {
if (event.state) { // If the event has a state object, restore that state
// Note that event.state is a deep copy of the saved state object
// so we can modify it without altering the saved value.
state = event.state; // Restore the historical state
display(state); // Display the restored state
}
else {
// When we load the page for the first time, we'll get a popstate event
// with no state. Replace that null state with our real state: see the
// comment in newgame(). No need to call display() here.
history.replaceState(state, "", "#guess" + state.guessnum);
}
};
// This event handler is invoked each time the user guesses a number.
// It updates the game state, saves it, and displays it.
function handleGuess() {
// Get the user's guess from the input field
var g = parseInt(this.value);
// If it is a number and is in the right range
if ((g > state.low) && (g < state.high)) {
// Update the state object based on this guess
if (g < state.n) state.low = g;
else if (g > state.n) state.high = g;
state.guess = g;
state.guessnum++;
// Now save the new state in the browser's history
save(state);
// Modify the document to respond to the user's guess
display(state);
}
else { // An invalid guess: don't push a new history state
alert("Please enter a number greater than " + state.low +
" and less than " + state.high);
}
}
// Modify the document to display the current state of the game.
function display(state) {
// Display document heading and title
ui.heading.innerHTML = document.title =
"I'm thinking of a number between " +
state.low + " and " + state.high + ".";
// Display a visual representation of the range of numbers using a table
ui.low.style.width = state.low + "%";
ui.mid.style.width = (state.high-state.low) + "%";
ui.high.style.width = (100-state.high) + "%";
// Make sure the input field is visible, empty, and focused
ui.input.style.visibility = "visible";
ui.input.value = "";
ui.input.focus();
// Set the prompt based on the user's most recent guess
if (state.guess === undefined)
ui.prompt.innerHTML = "Type your guess and hit Enter: ";
else if (state.guess < state.n)
ui.prompt.innerHTML = state.guess + " is too low. Guess again: ";
else if (state.guess > state.n)
ui.prompt.innerHTML = state.guess + " is too high. Guess again: ";
else {
// When correct, hide the input field and show a Play Again button.
ui.input.style.visibility = "hidden"; // No more guesses now
ui.heading.innerHTML = document.title = state.guess + " is correct! ";
ui.prompt.innerHTML =
"You Win! <button onclick='newgame(true)'>Play Again</button>";
}
}
</script>
<style> /* CSS styles to make the game look good */
#prompt { font-size: 16pt; }
table { width: 90%; margin:10px; margin-left:5%; }
#low, #high { background-color: lightgray; height: 1em; }
#mid { background-color: green; }
</style>
</head>
<body><!-- The HTML elements below are the game UI -->
<!-- Game title and textual representation of the range of numbers -->
<h1 id="heading">I'm thinking of a number...</h1>
<!-- a visual representation of the numbers that haven't been ruled out -->
<table><tr><td id="low"></td><td id="mid"></td><td id="high"></td></tr></table>
<!-- Where the user enters their guess -->
<label id="prompt"></label><input id="input" type="text">
</body></html>


<!DOCTYPE html>
<!--
This is a Twitter search gadget. Include it in any webpage, inside an
iframe, and ask it to search for things by sending it a query string with
postMessage(). Since it is in an <iframe> and not a <script>, it can't
mess around with the containing document.
-->
<html>
<head>
<style>body { font: 9pt sans-serif; }</style>
<!-- Use jQuery for its jQuery.getJSON() utility -->
<script src="http://code.jquery.com/jquery-1.4.4.min.js"/></script>
<script>
// We ought to just be able to use window.onmessage, but some older browsers
// (e.g., Firefox 3) don't support it, so we do it this way instead.
if (window.addEventListener)
window.addEventListener("message", handleMessage, false);
else
window.attachEvent("onmessage", handleMessage); // For IE8
function handleMessage(e) {
// We don't care what the origin of this message is: we're willing
// to search Twitter for anyone who asks us. We do expect the message
// to come from the window that contains us, however.
if (e.source !== window.parent) return;
var searchterm = e.data; // This is what we were asked to search for
// Use jQuery Ajax utlities and the Twitter search API to find
// tweets matching the message.
jQuery.getJSON("http://search.twitter.com/search.json?callback=?",
{ q: searchterm },
function(data) { // Called with request results
var tweets = data.results;
// Build an HTML document to display these results
var escaped = searchterm.replace("<", "&lt;");
var html = "<h2>" + escaped + "</h2>";
if (tweets.length == 0) {
html += "No tweets found";
}
else {
html += "<dl>"; // <dl> list of results
for(var i = 0; i < tweets.length; i++) {
var tweet = tweets[i];
var text = tweet.text;
var from = tweet.from_user;
var tweeturl = "http://twitter.com/#!/" +
from + "/status/" + tweet.id_str;
html += "<dt><a target='_blank' href='" +
tweeturl + "'>" + tweet.from_user +
"</a></dt><dd>" + tweet.text + "</dd>";
}
html += "</dl>";
}
// Set the <iframe> document
document.body.innerHTML = html;
});
}
$(function() {
// Let our container know we're here and ready to search.
// The container can't send any messages to us before it gets this message
// from us because we won't be here to receive the message yet.
// Normally, containers can just wait for an onload event to know that all
// of their <iframe>s have loaded. We send this message for containers that
// want to start searching Twitter even before they get their onload event.
// We don't know the origin of our container, so use * so that the browser
// will deliver it to anyone.
window.parent.postMessage("Twitter Search v0.1", "*");
});
</script>
</head>
<body>
</body>
</html>


// use moves the mouse over them, the gadget searches for the link's URL.
// This allows the user to see what people are tweeting about the link
// destination before clicking on it.
window.addEventListener("load", function() { // Won't work in IE < 9
var origin = "http://davidflanagan.com"; // Gadget origin
var gadget = "/demos/TwitterSearch.html"; // Gadget path
var iframe = document.createElement("iframe"); // Create the iframe
iframe.src = origin + gadget; // Set its URL
iframe.width = "250"; // 250 pixels wide
iframe.height = "100%"; // Full document height
iframe.style.cssFloat = "right"; // Flush right
// Insert the iframe at the start of the document
document.body.insertBefore(iframe, document.body.firstChild);
// Now find all links and hook them up to the gadget
var links = document.getElementsByTagName("a");
for(var i = 0; i < links.length; i++) {
// addEventListener doesn't work in IE8 and before
links[i].addEventListener("mouseover", function() {
// Send the url as the search term, and only deliver it if the
// iframe is still displaying a document from davidflanagan.com
iframe.contentWindow.postMessage(this.href, origin);
}, false);
}
}, false);


var loader = new Worker("utils/loader.js");
loader.postMessage("file.txt");

worker.onmessage = function(e) {
var message = e.data; // Get message from event
console.log("URL contents: " + message); // Do something with it
}


worker.onerror = function(e) {
// Log the error message, including worker filename and line number
console.log("Error at " + e.filename + ":" + e.lineno + ": " +
e.message);
}

// Before we start working, load the classes and utilities we'll need
importScripts("collections/Set.js", "collections/Map.js", "utils/base64.js");


// Asynchronously replace the contents of the image with a smeared version.
// Use it like this: <img src="testimage.jpg" onclick="smear(this)"/>
function smear(img) {
// Create an offscreen <canvas> the same size as the image
var canvas = document.createElement("canvas");
canvas.width = img.width;
canvas.height = img.height;
// Copy the image into the canvas, then extract its pixels
var context = canvas.getContext("2d");
context.drawImage(img, 0, 0);
var pixels = context.getImageData(0,0,img.width,img.height)
// Send the pixels to a worker thread
var worker = new Worker("SmearWorker.js"); // Create worker
worker.postMessage(pixels); // Copy and send pixels
// Register a handler to get the worker's response
worker.onmessage = function(e) {
var smeared_pixels = e.data; // Pixels from worker
context.putImageData(smeared_pixels, 0, 0); // Copy them to the canvas
img.src = canvas.toDataURL(); // And then to the img
worker.terminate(); // Stop the worker thread
canvas.width = canvas.height = 0; // Don't keep pixels around
}
}



// Get an ImageData object from the main thread, process it, send it back
onmessage = function(e) { postMessage(smear(e.data)); }
// Smear the ImageData pixels to the right, producing a motion blur.
// For large images, this function does a lot of computation and would
// cause UI responsiveness issues if it was used on the main thread.
function smear(pixels) {
var data = pixels.data, width = pixels.width, height = pixels.height;
var n = 10, m = n-1; // Make n bigger for more smearing
for(var row = 0; row < height; row++) { // For each row
var i = row*width*4 + 4; // 2nd pixel offset
for(var col = 1; col < width; col++, i += 4) { // For each column
data[i] = (data[i] + data[i-4]*m)/n; // Red pixel component
data[i+1] = (data[i+1] + data[i-3]*m)/n; // Green
data[i+2] = (data[i+2] + data[i-2]*m)/n; // Blue
data[i+3] = (data[i+3] + data[i-1]*m)/n; // Alpha component
}
}
return pixels;
}


// Messages are expected to be arrays of URLs. Synchronously fetch the
// contents of each URL as a string and send back an array of those strings.
onmessage = function(e) {
var urls = e.data; // Our input: the URLs to fetch
var contents = []; // Our output: the contents of those URLs
for(var i = 0; i < urls.length; i++) {
    var url = urls[i]; // For each URL
var xhr = new XMLHttpRequest(); // Begin an HTTP request
xhr.open("GET", url, false); // false makes this synchronous
xhr.send(); // Blocks until response is complete
if (xhr.status !== 200) // Throw an error if request failed
throw Error(xhr.status + " " + xhr.statusText + ": " + url);
contents.push(xhr.responseText); // Otherwise, store the URL contents
}
// Finally, send the array of URL contents back to the main thread
postMessage(contents);
}


var bytes = new Uint8Array(1024); // One kilobyte of bytes
for(var i = 0; i < bytes.length; i++) // For each element of the array
bytes[i] = i & 0xFF; // Set it to the low 8 bits of index
var copy = new Uint8Array(bytes); // Make a copy of the array
var ints = new Int32Array([0,1,2,3]); // A typed array holding these 4 ints


// Return the largest prime smaller than n, using the sieve of Eratosthenes
function sieve(n) {
var a = new Int8Array(n+1); // a[x] will be 1 if x is composite
var max = Math.floor(Math.sqrt(n)); // Don't do factors higher than this
var p = 2; // 2 is the first prime
while(p <= max) { // For primes less than max
for(var i = 2*p; i <= n; i += p) // Mark multiples of p as composite
a[i] = 1;
while(a[++p]) /* empty */; // The next unmarked index is prime
}
while(a[n]) n--; // Loop backward to find the last prime
return n; // And return it
}

var matrix = new Float64Array(9); // A 3x3 matrix
var 3dPoint = new Int16Array(3); // A point in 3D space
var rgba = new Uint8Array(4); // A 4-byte RGBA pixel value
var sudoku = new Uint8Array(81); // A 9x9 sudoku board


var bytes = new Uint8Array(1024) // A 1K buffer
var pattern = new Uint8Array([0,1,2,3]); // An array of 4 bytes
bytes.set(pattern); // Copy them to the start of another byte array
bytes.set(pattern, 4); // Copy them again at a different offset
bytes.set([0,1,2,3], 8); // Or just copy values direct from a regular array


var ints = new Int16Array([0,1,2,3,4,5,6,7,8,9]); // 10 short integers
var last3 = ints.subaarray(ints.length-3, ints.length); // Last 3 of them
last3[0] // => 7: this is the same as ints[7]

ints[9] = -1; // Change a value in the original array and...
last3[2] // => -1: it also changes in the subarray

last3.buffer // => returns an ArrayBuffer object
last3.buffer == ints.buffer // => true: both are views of the same buffer
last3.byteOffset // => 14: this view starts at byte 14 of the buffer
last3.byteLength // => 6: this view is 6 bytes (3 16-bit ints) long

last3.byteLength // => 6: this view is 6 bytes long
last3.buffer.byteLength // => 20: but the underlying buffer has 20 bytes


var bytes = new Uint8Array(8); // Allocate 8 bytes
bytes[0] = 1; // Set the first byte to 1
bytes.buffer[0] // => undefined: buffer doesn't have index 0
bytes.buffer[1] = 255; // Try incorrectly to set a byte in the buffer
bytes.buffer[1] // => 255: this just sets a regular JS property
bytes[1] // => 0: the line above did not set the byte


var buf = new ArrayBuffer(1024*1024); // One megabyte
var asbytes = new Uint8Array(buf); // Viewed as bytes
var asints = new Int32Array(buf); // Viewed as 32-bit signed integer
var lastK = new Uint8Array(buf,1023*1024); // Last kilobyte as bytes
var ints2 = new Int32Array(buf, 1024, 256); // 2nd kilobyte as 256 integers

// get bytes 00 00 00 01 instead.
var little_endian = new Int8Array(new Int32Array([1]).buffer)[0] === 1;

var data; // Assume this is an ArrayBuffer from the network
var view = DataView(data); // Create a view of it
var int = view.getInt32(0); // Big-endian 32-bit signed int from byte 0
int = view.getInt32(4,false); // Next 32-bit int is also big-endian
int = view.getInt32(8,true) // Next 4 bytes as a little-endian signed int
view.setInt32(8,int,false); // Write it back in big-endian format

var blob = ... // We'll see how to obtain a Blob later
blob.size // Size of the Blob in bytes
blob.type // MIME type of the Blob, or "" if unknown
var subblob = blob.slice(0,1024, "text/plain"); // First 1K of the Blob as text
var last = blob.slice(blob.size-1024, 1024); // Last 1K of the Blob, untyped


<script>
// Log information about a list of selected files
function fileinfo(files) {
for(var i = 0; i < files.length; i++) { // files is an array-like object
var f = files[i];
console.log(f.name, // Name only: no path
f.size, f.type, // size and type are Blob properties
f.lastModifiedDate); // another File property
}
}
</script>
<!-- Allow selection of multiple image files and pass them to fileinfo()-->
<input type="file" accept="image/*" multiple onchange="fileinfo(this.files)"/>



// GET the contents of the url as a Blob and pass it to the specified callback.
// This code is untested: no browsers supported this API when it was written.
function getBlob(url, callback) {
var xhr = new XMLHttpRequest(); // Create new XHR object
xhr.open("GET", url); // Specify URL to fetch
xhr.responseType = "blob" // We'd like a Blob, please
xhr.onload = function() { // onload is easier than onreadystatechange
callback(xhr.response); // Pass the blob to our callback
} // Note .response, not .responseText
xhr.send(null); // Send the request now
}


// Create a new BlobBuilder
var bb = new BlobBuilder();
// Append a string to the blob, and mark the end of the string with a NUL char
bb.append("This blob contains this text and 10 big-endian 32-bit signed ints.");
bb.append("\0"); // NUL-terminate the string to mark its end
// Store some data into an ArrayBuffer
var ab = new ArrayBuffer(4*10);
var dv = new DataView(ab);
for(var i = 0; i < 10; i++) dv.setInt32(i*4,i);
// Append the ArrayBuffer to the Blob

bb.append(ab);
// Now get the blob from the builder, specifying a made-up MIME type
var blob = bb.getBlob("x-optional/mime-type-here");


var getBlobURL = (window.URL && URL.createObjectURL.bind(URL)) ||
(window.webkitURL && webkitURL.createObjectURL.bind(webkitURL)) ||
window.createObjectURL;


<!DOCTYPE html>
<html><head>
<script>
// name of the createObjectURL() function
var getBlobURL = (window.URL && URL.createObjectURL.bind(URL)) ||
(window.webkitURL && webkitURL.createObjectURL.bind(webkitURL)) ||
window.createObjectURL;
var revokeBlobURL = (window.URL && URL.revokeObjectURL.bind(URL)) ||
(window.webkitURL && webkitURL.revokeObjectURL.bind(webkitURL)) ||
window.revokeObjectURL;
// When the document is loaded, add event handlers to the droptarget element
// so that it can handle drops of files
window.onload = function() {
// Find the element we want to add handlers to.
var droptarget = document.getElementById("droptarget");
// When the user starts dragging files over the droptarget, highlight it.
droptarget.ondragenter = function(e) {
// If the drag is something other than files, ignore it.
// The HTML5 dropzone attribute will simplify this when implemented.
var types = e.dataTransfer.types;
if (!types ||
(types.contains && types.contains("Files")) ||
(types.indexOf && types.indexOf("Files") != -1)) {
droptarget.classList.add("active"); // Highlight droptarget
return false; // We're interested in the drag
}
};
// Unhighlight the drop zone if the user moves out of it
droptarget.ondragleave = function() {
droptarget.classList.remove("active");
};
// This handler just tells the browser to keep sending notifications
droptarget.ondragover = function(e) { return false; };
// When the user drops files on us, get their URLs and display thumbnails.
droptarget.ondrop = function(e) {
var files = e.dataTransfer.files; // The dropped files
for(var i = 0; i < files.length; i++) { // Loop through them all
var type = files[i].type;
if (type.substring(0,6) !== "image/") // Skip any nonimages
continue;
var img = document.createElement("img"); // Create an <img> element
img.src = getBlobURL(files[i]); // Use Blob URL with <img>
img.onload = function() { // When it loads
this.width = 100; // adjust its size and
document.body.appendChild(this); // insert into document.
revokeBlobURL(this.src); // But don't leak memory!
}
}
droptarget.classList.remove("active"); // Unhighlight droptarget
return false; // We've handled the drop
}
};
</script>
<style> /* Simple styles for the file drop target */
#droptarget { border: solid black 2px; width: 200px; height: 200px; }
#droptarget.active { border: solid red 4px; }
</style>
</head>
<body> <!-- The document starts off with just the file drop target -->
<div id="droptarget">Drop Image Files Here</div>
</body>
</html>



<script>
// Read the specified text file and display it in the <pre> element below
function readfile(f) {
var reader = new FileReader(); // Create a FileReader object
reader.readAsText(f); // Read the file
reader.onload = function() { // Define an event handler
var text = reader.result; // This is the file contents
var out = document.getElementById("output"); // Find output element
out.innerHTML = ""; // Clear it
out.appendChild(document.createTextNode(text)); // Display file contents
}
reader.onerror = function(e) { // If anything goes wrong
console.log("Error", e); // Just log it
};
}
</script>
Select the file to display:
<input type="file" onchange="readfile(this.files[0])"></input>
<pre id="output"></pre>


<script>
// Examine the first 4 bytes of the specified blob. If this "magic number"
// identifies the type of the file, asynchronously set a property on the Blob.
function typefile(file) {
var slice = file.slice(0,4); // Only read the start of the file
var reader = new FileReader(); // Create an asynchronous FileReader
reader.readAsArrayBuffer(slice); // Read the slice of the file
reader.onload = function(e) {
var buffer = reader.result; // The result ArrayBuffer
var view = new DataView(buffer); // Get access to the result bytes
var magic = view.getUint32(0, false); // Read 4 bytes, big-endian
switch(magic) { // Determine file type from them
case 0x89504E47: file.verified_type = "image/png"; break;
case 0x47494638: file.verified_type = "image/gif"; break;
case 0x25504446: file.verified_type = "application/pdf"; break;
case 0x504b0304: file.verified_type = "application/zip"; break;
}
console.log(file.name, file.verified_type);
};
}
</script>
<input type="file" onchange="typefile(this.files[0])"></input>


// Obtaining a filesystem synchronously. Pass filesystem lifetime and size.
// Returns a filesystem object or raises an exception.
var fs = requestFileSystemSync(PERSISTENT, 1024*1024);
// The asynchronous version uses callback functions for success and error
requestFileSystem(TEMPORARY, // lifetime
50*1024*1024, // size: 50Mb
function(fs) { // called with the filesystem object
// Use fs here
}
function(e) { // called with an error object onerror
console.log(e); // Or handle it some other way
});



// This example doesn't include any error callbacks.
requestFileSystem(PERSISTENT, 10*1024*1024, function(fs) { // Get filesystem
fs.root.getFile("hello.txt", {}, function(entry) { // Get FileEntry
entry.file(function(file) { // Get File
var reader = new FileReader();
reader.readAsText(file);
reader.onload = function() { // Get file content
console.log(reader.result);
};
});
});
});


// requestFileSystem() gets us a sandboxed local filesystem accessible only
// to apps from this origin. We can read and write files at will, but
// can't get out of the sandbox to access the rest of the system.
var filesystem; // Assume this is initialized before the funcs below are called.
requestFileSystem(PERSISTENT, // Or TEMPORARY for cache files
10*1024*1024, // We'd like 10 megabytes, please
function(fs) { // When done, call this function
filesystem = fs; // Just save the filesystem into
}, // a global variable.
logerr); // Call this if an error occurs
// Read the contents of the specified file as text and pass them to callback.
function readTextFile(path, callback) {
// Call getFile() to find the FileEntry for the specified filename
filesystem.root.getFile(path, {}, function(entry) {
// This function is called with the FileEntry for the file
// Now we call the FileEntry.file() method to get the File object
entry.file(function(file) { // Call this with the File
var reader = new FileReader(); // Create a FileReader
reader.readAsText(file); // And read the file
reader.onload = function() { // When read successful
callback(reader.result); // Pass it to the callback
}
reader.onerror = logerr; // Log readAsText() errors
}, logerr); // Log file() errors
},
logerr); // Log getFile() errors
}
// Append the specified contents to the file at the specified path, creating
// a new file if no file by that name already exists. Call callback when done.
function appendToFile(path, contents, callback) {
// filesystem.root is the root directory.
filesystem.root.getFile( // Get a FileEntry object
path, // The name and path of the file we want
{create:true}, // Create it if it doesn't already exist
function(entry) { // Call this when it has been found
entry.createWriter( // Create a FileWriter object for the file
function(writer) { // Call this function when created
// By default a writer starts at the beginning of the file.
// We want to start writing at the end of the file
writer.seek(writer.length); // Move to end of file
// Convert file contents to a Blob. The contents argument
// can be a string or a Blob or an ArrayBuffer.
var bb = new BlobBuilder()
bb.append(contents);
var blob = bb.getBlob();
// Now write the blob to the file
writer.write(blob);
writer.onerror = logerr; // Log errors from write()
if (callback) // If there is a callback
writer.onwrite = callback; // call it on success
},
logerr); // Log errors from createWriter()
},
logerr); // Log errors from getFile()
}
// Delete the named file, calling the optional callback when done
function deleteFile(name, callback) {
filesystem.root.getFile(name, {}, // Get FileEntry for named file
function(entry) { // Pass the FileEntry here
entry.remove(callback, // Delete the FileEntry
logerr); // Or log remove() error
},
logerr); // Log a getFile() error
}
// Create a new directory with the specified name
function makeDirectory(name, callback) {
filesystem.root.getDirectory(name, // Name of directory to create
{ // Options
create: true, // Create, if doesn't exist
exclusive:true // Error if it does exist
},
callback, // Call this when done
logerr); // Log any errors
}
// Read the contents of the specified directory, and pass them, as an array
// of strings, to the specified callback function
function listFiles(path, callback) {
// If no directory specified, list the root directory. Otherwise, look up
// the named directory and list it (or log an error looking it up).
if (!path) getFiles(filesystem.root);
else filesystem.root.getDirectory(path, {}, getFiles, logerr);
function getFiles(dir) { // This function is used above
var reader = dir.createReader(); // A DirectoryReader object
var list = []; // Where we store filenames
reader.readEntries(handleEntries, // Pass entries to function below
logerr); // or log an error.
// Reading directories can be a multistep process. We have to keep
// calling readEntries() until we get an empty array. Then we're done
// and we can pass the full list to the user's callback function.
function handleEntries(entries) {
if (entries.length == 0) callback(list); // We're done
else {
// Otherwise, add these entries to the list and ask for more
// The array-like object contains FileEntry objects and
// we need to get the name of each one.
for(var i = 0; i < entries.length; i++) {
    var name = entries[i].name; // Get entry name
if (entries[i].isDirectory) name += "/"; // Mark directories
list.push(name); // Add to list
}
// Now get the next batch of entries
reader.readEntries(handleEntries, logerr);
}
}
}
}



// Filesystem utilities using the synchronous API in a worker thread
var filesystem = requestFileSystemSync(PERSISTENT, 10*1024*1024);
function readTextFile(name) {
// Get a File from a FileEntry from the root DirectoryEntry
var file = filesystem.root.getFile(name).file();
// Use the synchronous FileReader API to read it
return new FileReaderSync().readAsText(file);
}
function appendToFile(name, contents) {
// Get a FileWriter from a FileEntry from the root DirectoryEntry
var writer = filesystem.root.getFile(name, {create:true}).createWriter();
writer.seek(writer.length); // Start at the end of the file
var bb = new BlobBuilder() // Build the file contents into a Blob
bb.append(contents);
writer.write(bb.getBlob()); // Now write the blob to the file
}
function deleteFile(name) {
filesystem.root.getFile(name).remove();
}
function makeDirectory(name) {
filesystem.root.getDirectory(name, { create: true, exclusive:true });
}
function listFiles(path) {
var dir = filesystem.root;
if (path) dir = dir.getDirectory(path);
var lister = dir.createReader();
var list = [];
do {
var entries = lister.readEntries();
for(var i = 0; i < entries.length; i++) {
var name = entries[i].name;
if (entries[i].isDirectory) name += "/";
list.push(name);
}
} while(entries.length > 0);
return list;
}
// Allow the main thread to use these utilities by sending a message
onmessage = function(e) {
// We expect the message to be an object like this:
// { function: "appendToFile", args: ["test", "testing, testing"]}
// We invoke the specified function with the specified args and
// post the message back
var f = self[e.data.function];
var result = f.apply(null, e.data.args);
postMessage(result);
};


<!DOCTYPE html>
<html>
<head>
<title>Zipcode Database</title>
<script>
// IndexedDB implementations still use API prefixes
var indexedDB = window.indexedDB || // Use the standard DB API
window.mozIndexedDB || // Or Firefox's early version of it
window.webkitIndexedDB; // Or Chrome's early version
// Firefox does not prefix these two:
var IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction;
var IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange;
// We'll use this function to log any database errors that occur
function logerr(e) {
console.log("IndexedDB error" + e.code + ": " + e.message);
}
// This function asynchronously obtains the database object (creating and
// initializing the database if necessary) and passes it to the function f().
function withDB(f) {
var request = indexedDB.open("zipcodes"); // Request the zipcode database
request.onerror = logerr; // Log any errors
request.onsuccess = function() { // Or call this when done
var db = request.result; // The result of the request is the database
// You can always open a database, even if it doesn't exist.
// We check the version to find out whether the DB has been created and
// initialized yet. If not, we have to go do that. But if the db is
// already set up, we just pass it to the callback function f().
if (db.version === "1") f(db); // If db is inited, pass it to f()
else initdb(db,f); // Otherwise initialize it first
}
}
// Given a zip code, find out what city it belongs to and asynchronously
// pass the name of that city to the specified callback function.
function lookupCity(zip, callback) {
withDB(function(db) {
// Create a transaction object for this query
var transaction = db.transaction(["zipcodes"], // Object stores we need
IDBTransaction.READ_ONLY, // No updates
0); // No timeout
// Get the object store from the transaction
var objects = transaction.objectStore("zipcodes");
// Now request the object that matches the specified zipcode key.
// The lines above were synchronous, but this one is async
var request = objects.get(zip);

request.onerror = logerr; // Log any errors that occur
request.onsuccess = function() { // Pass the result to this function
// The result object is now in the request.result
var object = request.result;
if (object) // If we found a match, pass city and state to callback
callback(object.city + ", " + object.state);
else // Otherwise, tell the callback that we failed
callback("Unknown zip code");
}
});
}
// Given the name of a city find all zipcodes for all cities (in any state)
// with that name (case-sensitive). Asynchronously pass the results, one at
// a time, to the specified callback function
function lookupZipcodes(city, callback) {
withDB(function(db) {
// As above, we create a transaction and get the object store
var transaction = db.transaction(["zipcodes"],
IDBTransaction.READ_ONLY, 0);
var store = transaction.objectStore("zipcodes");
// This time we get the city index of the object store
var index = store.index("cities");
// This query is likely to have many results, so we have to use a
// cursor object to retrieve them all. To create a cursor, we need
// a range object that represents the range of keys
var range = new IDBKeyRange.only(city); // A range with only() one key
// Everything above has been synchronous.
// Now we request a cursor, which will be returned asynchronously.
var request = index.openCursor(range); // Request the cursor
request.onerror = logerr; // Log errors
request.onsuccess = function() { // Pass cursor to this function
// This event handler will be invoked multiple times, once
// for each record that matches the query, and then once more
// with a null cursor to indicate that we're done.
var cursor = request.result // The cursor is in request.result
if (!cursor) return; // No cursor means no more results
var object = cursor.value // Get the matching record
callback(object); // Pass it to the callback
cursor.continue(); // Ask for the next matching record
};
});
}
// This function is used by an onchange callback in the document below
// It makes a DB request and displays the result
function displayCity(zip) {
lookupCity(zip, function(s) { document.getElementById('city').value = s; });
}
// This is another onchange callback used in the document below.
// It makes a DB request and displays the results
function displayZipcodes(city) {
var output = document.getElementById("zipcodes");
output.innerHTML = "Matching zipcodes:";
lookupZipcodes(city, function(o) {
var div = document.createElement("div");
var text = o.zipcode + ": " + o.city + ", " + o.state;
div.appendChild(document.createTextNode(text));
output.appendChild(div);
});
}
// Set up the structure of the database and populate it with data, then pass
// the database to the function f(). withDB() calls this function if the
// database has not been initialized yet. This is the trickiest part of the
// program, so we've saved it for last.
function initdb(db, f) {
// Downloading zipcode data and storing it in the database can take
// a while the first time a user runs this application. So we have to
// provide notification while that is going on.
var statusline = document.createElement("div");
statusline.style.cssText =
"position:fixed; left:0px; top:0px; width:100%;" +
"color:white; background-color: black; font: bold 18pt sans-serif;" +
"padding: 10px; ";
document.body.appendChild(statusline);
function status(msg) { statusline.innerHTML = msg.toString(); };
status("Initializing zipcode database");
// The only time you can define or alter the structure of an IndexedDB
// database is in the onsucess handler of a setVersion request.
var request = db.setVersion("1"); // Try to update the DB version
request.onerror = status; // Display status on fail
request.onsuccess = function() { // Otherwise call this function
// Our zipcode database includes only one object store.
// It will hold objects that look like this: {
// zipcode: "02134", // send it to Zoom! :-)
// city: "Allston",
// state: "MA",
// latitude: "42.355147",
// longitude: "-71.13164"
// }
//
// We'll use the "zipcode" property as the database key
// And we'll also create an index using the city name
// Create the object store, specifying a name for the store and
// an options object that includes the "key path" specifying the
// property name of the key field for this store. (If we omit the
// key path, IndexedDB will define its own unique integer key.)
var store = db.createObjectStore("zipcodes", // store name
{ keyPath: "zipcode" });
// Now index the object store by city name as well as by zipcode.
// With this method the key path string is passed directly as a
// required argument rather than as part of an options object.
store.createIndex("cities", "city");
// We use XMLHttpRequest to download the data. But use the new XHR2
// onload and onprogress events to process it as it arrives
var xhr = new XMLHttpRequest(); // An XHR to download the data
xhr.open("GET", "zipcodes.csv"); // HTTP GET for this URL
xhr.send(); // Start right away
xhr.onerror = status; // Display any error codes
var lastChar = 0, numlines = 0; // How much have we already processed?
// Handle the database file in chunks as it arrives
xhr.onprogress = xhr.onload = function(e) { // Two handlers in one!
// We'll process the chunk between lastChar and the last newline
// that we've received. (We need to look for newlines so we don't
// process partial records)
var lastNewline = xhr.responseText.lastIndexOf("\n");
if (lastNewline > lastChar) {
var chunk = xhr.responseText.substring(lastChar, lastNewline)
lastChar = lastNewline + 1; // Where to start next time
// Now break the new chunk of data into individual lines
var lines = chunk.split("\n");
numlines += lines.length;
// In order to insert zipcode data into the database we need a
// transaction object. All the database insertions we make
// using this object will be commited to the database when this
// function returns and the browser goes back to the event
// loop. To create our transaction object, we need to specify
// which object stores we'll be using (we only have one) and we
// need to tell it that we'll be doing writes to the database,
// not just reads:
var transaction = db.transaction(["zipcodes"], // object stores
IDBTransaction.READ_WRITE);
// Get our object store from the transaction
var store = transaction.objectStore("zipcodes");
// Now loop through the lines of the zipcode file, create
// objects for them, and add them to the object store.
for(var i = 0; i < lines.length; i++) {
var fields = lines[i].split(","); // Comma-separated values
var record = { // This is the object we'll store
zipcode: fields[0], // All properties are string
city: fields[1],
state: fields[2],
latitude: fields[3],
longitude: fields[4]
};
// The best part about the IndexedDB API is that object
// stores are *really* simple. Here's how we add a record:
store.put(record); // Or use add() to avoid overwriting
}
status("Initializing zipcode database: loaded "
+ numlines + " records.");
}
if (e.type == "load") {
// If this was the final load event, then we've sent all our
// zipcode data to the database. But since we've just blasted
// it with some 40,000 records, it may still be processing.
// So we'll make a simple query. When it succeeds, we know
// that the database is ready to go, and we can then remove
// the status line and finally call the function f() that was
// passed to withDB() so long ago
lookupCity("02134", function(s) { // Allston, MA
document.body.removeChild(statusline);
withDB(f);
});
}
}
}
}
</script>
</head>
<body>
<p>Enter a zip code to find its city:</p>
Zipcode: <input onchange="displayCity(this.value)"></input>
City: <output id="city"></output>
</div>
<div>
<p>Enter a city name (case sensitive, without state) to find cities and their zipcodes:</p>
City: <input onchange="displayZipcodes(this.value)"></input>
<div id="zipcodes"></div>
</div>
<p><i>This example is only known to work in Firefox 4 and Chrome 11.</i></p>
<p><i>Your first query may take a very long time to complete.</i></p>
<p><i>You may need to start Chrome with --unlimited-quota-for-indexeddb</i></p>
</body>
</html>



var socket = new WebSocket("ws://ws.example.com:1234/resource");
socket.onopen = function(e) { /* The socket is now connected. */ };
socket.onclose = function(e) { /* The socket closed. */ };
socket.onerror = function(e) { /* Something went wrong! */ };
socket.onmessage = function(e) {
var message = e.data; /* The server sent us a message. */
};

socket.send("Hello, server!");


<script>
window.onload = function() {
// Take care of some UI details
var nick = prompt("Enter your nickname"); // Get user's nickname
var input = document.getElementById("input"); // Find the input field
input.focus(); // Set keyboard focus
// Open a WebSocket to send and receive chat messages on.
// Assume that the HTTP server we were downloaded from also functions as
// a websocket server, and use the same host name and port, but change
// from the http:// protocol to ws://
var socket = new WebSocket("ws://" + location.host + "/");
// This is how we receive messages from the server through the web socket
socket.onmessage = function(event) { // When a new message arrives
var msg = event.data; // Get text from event object
var node = document.createTextNode(msg); // Make it into a text node
var div = document.createElement("div"); // Create a <div>
div.appendChild(node); // Add text node to div
document.body.insertBefore(div, input); // And add div before input
input.scrollIntoView(); // Ensure input elt is visible
}
// This is how we send messages to the server through the web socket
input.onchange = function() { // When user strikes return
var msg = nick + ": " + input.value; // Username plus user's input
socket.send(msg); // Send it through the socket
input.value = ""; // Get ready for more input
}
};
</script>
<!-- The chat UI is just a single, wide text input field -->
<!-- New chat messages will be inserted before this element -->
<input id="input" style="width:100%"/>




var http = require('http'); // Use Node's HTTP server API
var ws = require('websocket-server'); // Use an external WebSocket library
// Read the source of the chat client at startup. Used below.
var clientui = require('fs').readFileSync("wschatclient.html");
// Create an HTTP server
var httpserver = new http.Server();
// When the HTTP server gets a new request, run this function
httpserver.on("request", function (request, response) {
// If the request was for "/", send the client-side chat UI.
if (request.url === "/") { // A request for the chat UI
response.writeHead(200, {"Content-Type": "text/html"});
response.write(clientui);
response.end();
}
else { // Send a 404 "Not Found" code for any other request
response.writeHead(404);
response.end();
}
});
// Now wrap a WebSocket server around the HTTP server
var wsserver = ws.createServer({server: httpserver});
// Call this function when we receive a new connection request
wsserver.on("connection", function(socket) {
socket.send("Welcome to the chat room."); // Greet the new client
socket.on("message", function(msg) { // Listen for msgs from the client
wsserver.broadcast(msg); // And broadcast them to everyone
});
});
// Run the server on port 8000. Starting the WebSocket server starts the
// HTTP server as well. Connect to http://localhost:8000/ to use it.
wsserver.listen(8000);